Give ovs_accel_flow_find_no_ct option to prioritize finding flows which do
recirculation instead of output. This allows us to support DPI, as using ct()
action results in 2 datapath flows, one with recirculate action (+ various
packet modification actions) and one with output action.

--- a/qsdk/qca/src/linux-4.4/net/openvswitch/datapath.c
+++ b/qsdk/qca/src/linux-4.4/net/openvswitch/datapath.c
@@ -2477,7 +2477,7 @@ void ovs_unregister_accelerator(struct o
 EXPORT_SYMBOL(ovs_unregister_accelerator);
 
 /* Find datapath flow rule using the key*/
-struct sw_flow *ovs_accel_flow_find(void *dp_inst, struct sw_flow_key *key)
+static struct sw_flow *ovs_accel_flow_find(void *dp_inst, struct sw_flow_key *key)
 {
 	struct datapath *dp = dp_inst;
 	struct sw_flow *flow;
@@ -2488,7 +2488,6 @@ struct sw_flow *ovs_accel_flow_find(void
 
 	return flow;
 }
-EXPORT_SYMBOL(ovs_accel_flow_find);
 
 /* Find datapath flow rule using MAC addresses*/
 struct sw_flow *ovs_accel_flow_find_by_mac(void *dp_inst,
@@ -2650,9 +2649,11 @@ static int ipv6_addr_masked_cmp(struct i
 /* Find datapath flow by matching using only fields ECM is actually aware of.
  * Must be called under rcu_read_lock()
  */
-static struct sw_flow *ovs_accel_flow_find_no_ct(struct datapath *dp, struct sw_flow_key *key)
+struct sw_flow *ovs_accel_flow_find_no_ct(void *dp_inst, struct sw_flow_key *key, bool try_find_recirc)
 {
+	struct datapath *dp = dp_inst;
 	struct table_instance *ti;
+	struct sw_flow *potential_flow = NULL;
 	struct sw_flow *flow = NULL;
 	struct sw_flow_key *flow_key;
 	struct sw_flow_key *flow_mask;
@@ -2719,19 +2720,23 @@ static struct sw_flow *ovs_accel_flow_fi
 					a = nla_next(a, &rem)) {
 				if (nla_type(a) == OVS_ACTION_ATTR_OUTPUT) {
 					output_count++;
+				} else if (nla_type(a) == OVS_ACTION_ATTR_RECIRC && try_find_recirc) {
+					return flow;
 				}
 			}
 
 			/* Only allow flows with output_count == 1 */
-			if (output_count != 1) {
-				continue;
-			}
+			if (output_count == 1) {
+				if (try_find_recirc == false) {
+					return flow;
+				}
 
-			return flow;
+				potential_flow = flow;
+			}
 		}
 	}
 
-	return NULL;
+	return potential_flow;
 }
 EXPORT_SYMBOL(ovs_accel_flow_find_no_ct);
 
@@ -2749,7 +2754,7 @@ int ovs_accel_flow_stats_update(void *dp
 
 	rcu_read_lock();
 
-	flow = ovs_accel_flow_find_no_ct(dp, key);
+	flow = ovs_accel_flow_find_no_ct(dp_inst, key, false);
 	if (flow) {
 		key = &flow->key;
 	}
--- a/qsdk/qca/src/linux-4.4/net/openvswitch/datapath.h
+++ b/qsdk/qca/src/linux-4.4/net/openvswitch/datapath.h
@@ -239,8 +239,8 @@ int ovs_register_accelerator(struct ovs_
 void ovs_unregister_accelerator(struct ovs_accel_callback *oac);
 int ovs_accel_flow_stats_update(void *dp, void *out_vport,
 				struct sw_flow_key *sf, int pkts, int bytes);
-struct sw_flow *ovs_accel_flow_find(void *dp, struct sw_flow_key *sfk);
 struct sw_flow *ovs_accel_flow_find_by_recirc(void *dp_inst, u32 recirc_id);
+struct sw_flow *ovs_accel_flow_find_no_ct(void *dp_inst, struct sw_flow_key *key, bool try_find_recirc);
 struct net_device *ovs_accel_dev_find(void *dp, int vport_no);
 struct net_device *ovs_accel_egress_dev_find(void *dp_inst,
 					     struct sw_flow_key *key,
