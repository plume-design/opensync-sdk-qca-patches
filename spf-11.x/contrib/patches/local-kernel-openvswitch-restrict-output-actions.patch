Make OVSMGR loop through flows until it finds a flow with exactly 1 output.
This should fix sometimes broken acceleration, when OVSMGR would always hit a
flow which only does recirculation and has no output. Should also prevent 
acceleration for flows with more than 1 output, which should never be
accelerated.
--- a/qsdk/qca/src/linux-4.4/net/openvswitch/datapath.c
+++ b/qsdk/qca/src/linux-4.4/net/openvswitch/datapath.c
@@ -2476,19 +2476,6 @@ void ovs_unregister_accelerator(struct o
 }
 EXPORT_SYMBOL(ovs_unregister_accelerator);
 
-/* Find datapath flow rule using the key*/
-static struct sw_flow *ovs_accel_flow_find(void *dp_inst, struct sw_flow_key *key)
-{
-	struct datapath *dp = dp_inst;
-	struct sw_flow *flow;
-
-	rcu_read_lock();
-	flow = ovs_flow_tbl_lookup(&dp->table, key);
-	rcu_read_unlock();
-
-	return flow;
-}
-
 /* Find datapath flow rule using MAC addresses*/
 struct sw_flow *ovs_accel_flow_find_by_mac(void *dp_inst,
 						struct net_device *indev,
@@ -2501,13 +2488,15 @@ struct sw_flow *ovs_accel_flow_find_by_m
 	struct sw_flow_actions *sf_acts;
 	const struct nlattr *a;
 	struct vport *vport;
-	bool flow_found = false;
+	int output_port;
+	int output_count;
 	int rem;
 	int i;
 
 	rcu_read_lock();
 	ti = rcu_dereference(dp->table.ti);
 
+	/* Search until we find a flow that has exactly 1 output */
 	for (i = 0; i < ti->n_buckets; i++) {
 		struct hlist_head *head = flex_array_get(ti->buckets, i);
 		struct hlist_node *n;
@@ -2517,68 +2506,64 @@ struct sw_flow *ovs_accel_flow_find_by_m
 
 		hlist_for_each_entry_safe(flow, n, head,
 				flow_table.node[ti->node_ver]) {
-			if ((flow->key.eth.type == type) &&
-			     ether_addr_equal(flow->key.eth.src, smac) &&
-			     ether_addr_equal(flow->key.eth.dst, dmac)) {
-				flow_found = true;
-				goto found;
+			if ((flow->key.eth.type != type) ||
+			     !ether_addr_equal(flow->key.eth.src, smac) ||
+			     !ether_addr_equal(flow->key.eth.dst, dmac)) {
+				continue;
 			}
-		}
-	}
-found:
-	if (!flow_found) {
-		rcu_read_unlock();
-		return NULL;
-	}
 
-	/*
-	 * Flow is found, check if ingress port matches indev.
-	 */
-	if (!indev) {
-		goto check_outdev;
-	}
+			/*
+			 * Flow matches, check if ingress port matches indev.
+			 */
+			if (!indev) {
+				goto check_outdev;
+			}
 
-	vport = ovs_vport_ovsl_rcu(dp, flow->key.phy.in_port);
-	if (!vport || (indev != vport->dev)) {
-		rcu_read_unlock();
-		return NULL;
-	}
+			vport = ovs_vport_ovsl_rcu(dp, flow->key.phy.in_port);
+			if (!vport || (indev != vport->dev)) {
+				continue;
+			}
 
 check_outdev:
-	/*
-	 * if outdev is NULL, then the API is called
-	 * to find the flow only.
-	 */
-	if (!outdev) {
-		rcu_read_unlock();
-		return flow;
-	}
+			/*
+			 * if outdev is NULL, then the API is called
+			 * to find the flow only.
+			 */
+			if (!outdev) {
+				rcu_read_unlock();
+		        return flow;
+			}
 
-	/*
-	 * Flow is found, check if output action is outdev
-	 */
-	flow_found = false;
-	sf_acts = rcu_dereference(flow->sf_acts);
-	for (a = sf_acts->actions, rem = sf_acts->actions_len; rem > 0;
-			a = nla_next(a, &rem)) {
-		int port_no;
+			/*
+			 * Flow is found, check if output action is outdev
+			 */
+			output_count = 0;
+			sf_acts = rcu_dereference(flow->sf_acts);
+			for (a = sf_acts->actions, rem = sf_acts->actions_len; rem > 0;
+					a = nla_next(a, &rem)) {
 
-		if (nla_type(a) != OVS_ACTION_ATTR_OUTPUT)
-			continue;
+				if (nla_type(a) != OVS_ACTION_ATTR_OUTPUT)
+					continue;
 
-		port_no = nla_get_u32(a);
-		vport = ovs_vport_ovsl_rcu(dp, port_no);
+				output_port = nla_get_u32(a);
+                output_count++;
+			}
 
-		if (vport && (outdev == vport->dev)) {
-			flow_found = true;
+			/* We only look for flows with exactly 1 output */
+            if (output_count != 1) {
+                continue;
+            }
+
+            vport = ovs_vport_ovsl_rcu(dp, output_port);
+            if (vport && (outdev == vport->dev)) {
+                rcu_read_unlock();
+		        return flow;
+            }
 		}
 	}
-
-	if (!flow_found)
-		flow = NULL;
-
+found:
 	rcu_read_unlock();
-	return flow;
+	return NULL;
 }
 EXPORT_SYMBOL(ovs_accel_flow_find_by_mac);
 
@@ -2835,7 +2820,7 @@ struct net_device *ovs_accel_egress_dev_
 	int rem;
 
 	rcu_read_lock();
-	flow = ovs_accel_flow_find(dp_inst, key);
+	flow = ovs_accel_flow_find_no_ct(dp_inst, key, false);
 	if (unlikely(!flow))
 		goto done;
 
