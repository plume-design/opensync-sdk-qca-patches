--- a/ovsmgr_dp.c
+++ b/ovsmgr_dp.c
@@ -1597,6 +1597,7 @@ enum ovsmgr_flow_status ovsmgr_dp_flow_i
 	int rem;
 	uint64_t prev_action = OVS_ACTION_ATTR_UNSPEC;
 	bool pop_vlan = false;
+	int output_count, output_port;
 
 	read_lock_bh(&ovsmgr_ctx.lock);
 
@@ -1704,6 +1705,8 @@ retry:
 	 * Flow is found, find if VLAN operations are needed and check
 	 * if egress port is allowed.
 	 */
+	output_count = 0;
+	output_port = -1;
 	rcu_read_lock();
 	acts = rcu_dereference(sf->sf_acts);
 
@@ -1711,14 +1714,8 @@ retry:
 	     a = nla_next(a, &rem)) {
 		switch (nla_type(a)) {
 		case OVS_ACTION_ATTR_OUTPUT:
-			if (out_port_num == nla_get_u32(a)) {
-				ovsmgr_info("%px: Found egress port in flow rule: %d\n", flow, out_port_num);
-				found_egress = true;
-				if (status == OVSMGR_FLOW_STATUS_DENY_ACCEL)
-					status = OVSMGR_FLOW_STATUS_ALLOW_ACCEL;
-				break;
-			}
-
+			output_count++;
+			output_port = nla_get_u32(a);
 			prev_action = OVS_ACTION_ATTR_OUTPUT;
 			break;
 		case OVS_ACTION_ATTR_PUSH_VLAN: {
@@ -1778,7 +1775,7 @@ retry:
 		case OVS_ACTION_ATTR_RECIRC: {
 			struct sw_flow *recirc_flow;
 			u32 recirc_id = nla_get_u32(a);
-			// printk(KERN_INFO "OVS_ACTION_ATTR_RECIRC action detected, making ovs_accel_flow_find_by_recirc call\n");
+
 			recirc_flow = ovs_accel_flow_find_by_recirc(nod->dp, recirc_id);
 			if (recirc_flow) {
 				/* Prepare for retry */
@@ -1790,16 +1787,16 @@ retry:
 			break;
 		}
 		}
-
-		/*
-		 * If the egress port is found then the job is done.
-		 */
-		if (found_egress) {
-			break;
-		}
 	}
 	rcu_read_unlock();
 
+	if (output_count == 1 && out_port_num == output_port) {
+		ovsmgr_info("%px: Found egress port in flow rule: %d\n", flow, out_port_num);
+		found_egress = true;
+		if (status == OVSMGR_FLOW_STATUS_DENY_ACCEL)
+			status = OVSMGR_FLOW_STATUS_ALLOW_ACCEL;
+	}
+
 	/*
 	 * Do not accelerate if flow->outdev is not part of output list
 	 */
